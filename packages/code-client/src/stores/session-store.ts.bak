/**
 * Session Store - Pure UI Client
 * Manages ONLY currentSessionId (which session is being viewed)
 *
 * Architecture: Server-driven, Pure UI Client
 * - Store ONLY stores currentSessionId (a simple string)
 * - All data fetching handled by tRPC React Query (server is source of truth)
 * - No business logic in client - just UI state
 * - PLUS: Optimistic currentSession for instant UI updates during streaming
 */

// import { createStore } from '../lib/create-store.js';
import type { ProviderId, Session } from '@sylphx/code-core';
import { getTRPCClient } from '../trpc-provider.js';
import { eventBus } from '../lib/event-bus.js';

export interface SessionState {
  // UI State: Which session is currently being viewed
  currentSessionId: string | null;

  // Optimistic State: Current session data for instant UI updates
  // This is set during optimistic updates (before server confirms)
  // and cleared when server data is fetched
  currentSession: Session | null;

  // Streaming State: Track if currently streaming to prevent server data overwrites
  isStreaming: boolean;

  // UI Actions: Simple state setters (synchronous)
  setCurrentSessionId: (sessionId: string | null) => void;
  setCurrentSession: (session: Session | null) => void;
  setIsStreaming: (isStreaming: boolean) => void;

  // Server Actions: Delegate to tRPC (return sessionId for convenience)
  createSession: (provider: ProviderId, model: string, agentId?: string, enabledRuleIds?: string[]) => Promise<string>;
  updateSessionModel: (sessionId: string, model: string) => Promise<void>;
  updateSessionProvider: (sessionId: string, provider: ProviderId, model: string) => Promise<void>;
  updateSessionTitle: (sessionId: string, title: string) => Promise<void>;
  updateSessionRules: (sessionId: string, enabledRuleIds: string[]) => Promise<void>;
  deleteSession: (sessionId: string) => Promise<void>;
}

// 0
  currentSessionId: null,
  currentSession: null,
  isStreaming: false,

  /**
   * Set current session ID (pure UI state)
   * Data will be fetched by React Query in components
   */
  setCurrentSessionId: (sessionId) => {
    set({ currentSessionId: sessionId });

    // Emit event for other stores to react
    eventBus.emit('session:changed', { sessionId });
  },

  /**
   * Set current session (optimistic state for instant UI updates)
   * Used during streaming to show messages immediately
   */
  setCurrentSession: (session) => {
    set({ currentSession: session });
  },

  /**
   * Set streaming state (prevents server data overwrites during streaming)
   */
  setIsStreaming: (isStreaming) => {
    set({ isStreaming });
  },

  /**
   * Create new session (server action)
   * Returns sessionId, sets it as current
   *
   * Note: Requires agentId and enabledRuleIds as parameters
   * Caller (UI component) should get these from settings store
   */
  createSession: async (provider, model, agentId?: string, enabledRuleIds?: string[]) => {
    const client = getTRPCClient();

    const session = await client.session.create.mutate({
      provider,
      model,
      agentId,
      enabledRuleIds,
    });

    // Set as current session (UI state only)
    set({ currentSessionId: session.id });

    // Emit event for other stores to react
    eventBus.emit('session:created', {
      sessionId: session.id,
      enabledRuleIds: session.enabledRuleIds || [],
    });

    return session.id;
  },

  /**
   * Update session model (server action)
   * React Query will refetch and update UI automatically
   */
  updateSessionModel: async (sessionId, model) => {
    const client = getTRPCClient();
    await client.session.updateModel.mutate({ sessionId, model });
  },

  /**
   * Update session provider (server action)
   * React Query will refetch and update UI automatically
   */
  updateSessionProvider: async (sessionId, provider, model) => {
    const client = getTRPCClient();
    await client.session.updateProvider.mutate({ sessionId, provider, model });
  },

  /**
   * Update session title (server action)
   * Updates local state immediately for instant UI feedback
   */
  updateSessionTitle: async (sessionId, title) => {
    const client = getTRPCClient();
    await client.session.updateTitle.mutate({ sessionId, title });

    // Update local state if this is the current session
    const state = get();
    if (state.currentSession && state.currentSession.id === sessionId) {
      set({
        currentSession: {
          ...state.currentSession,
          title,
        },
      });
    }
  },

  /**
   * Update session enabled rules (server action)
   * React Query will refetch and update UI automatically
   */
  updateSessionRules: async (sessionId, enabledRuleIds) => {
    const client = getTRPCClient();
    await client.session.updateRules.mutate({ sessionId, enabledRuleIds });

    // Emit event for other stores to react (if current session)
    if (get().currentSessionId === sessionId) {
      eventBus.emit('session:rulesUpdated', { sessionId, enabledRuleIds });
    }
  },

  /**
   * Delete session (server action)
   */
  deleteSession: async (sessionId) => {
    // Clear if it's the current session
    if (get().currentSessionId === sessionId) {
      set({ currentSessionId: null });
    }

    // Delete from database via tRPC
    const client = getTRPCClient();
    await client.session.delete.mutate({ sessionId });
  },
}));

/**
 * Setup event listeners
 * Called on module load and can be called again in tests after eventBus.clear()
 */
export function setupSessionStoreEventListeners() {
  eventBus.on('streaming:started', () => {
    useSessionStore.setState({ isStreaming: true });
  });

  eventBus.on('streaming:completed', () => {
    useSessionStore.setState({ isStreaming: false });
  });
}

// Subscribe to streaming events to track streaming state
setupSessionStoreEventListeners();
