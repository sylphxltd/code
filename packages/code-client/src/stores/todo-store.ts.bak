/**
 * Todo Store
 * Manages todo operations for sessions
 *
 * Single Responsibility: Todo lifecycle management
 */

// import { createStore } from '../lib/create-store.js';
import type { TodoUpdate } from '@sylphx/code-core';
import { getTRPCClient } from '../trpc-provider.js';

export interface TodoState {
  updateTodos: (sessionId: string, updates: TodoUpdate[]) => Promise<void>;
}

// 0
    /**
     * Update todos for a session
     */
    updateTodos: async (sessionId, updates) => {
      // Get session store
      const { useSessionStore } = await import('./session-store.js');
      const sessionStore = useSessionStore.getState();
      const { currentSession } = sessionStore;

      // Optimistic update if it's the current session
      if (sessionStore.currentSessionId === sessionId && currentSession) {
        useSessionStore.setState((state) => {
          if (!state.currentSession) return;

          const session = state.currentSession;

          for (const update of updates) {
            if (update.id === undefined || update.id === null) {
              // Add new todo
              const newId = session.nextTodoId;
              const maxOrdering =
                session.todos.length > 0 ? Math.max(...session.todos.map((t) => t.ordering)) : 0;

              session.todos.push({
                id: newId,
                content: update.content || '',
                activeForm: update.activeForm || '',
                status: update.status || 'pending',
                ordering: maxOrdering + 10,
              });
              session.nextTodoId = newId + 1;
            } else {
              // Update existing todo
              const todo = session.todos.find((t) => t.id === update.id);
              if (!todo) continue;

              if (update.content !== undefined) todo.content = update.content;
              if (update.activeForm !== undefined) todo.activeForm = update.activeForm;
              if (update.status !== undefined) todo.status = update.status;

              // Handle reordering
              if (update.reorder) {
                const { type, id: targetId } = update.reorder;

                if (type === 'top') {
                  const minOrdering = Math.min(...session.todos.map((t) => t.ordering));
                  todo.ordering = minOrdering - 10;
                } else if (type === 'last') {
                  const maxOrdering = Math.max(...session.todos.map((t) => t.ordering));
                  todo.ordering = maxOrdering + 10;
                } else if (type === 'before' && targetId !== undefined) {
                  const target = session.todos.find((t) => t.id === targetId);
                  if (target) {
                    const sorted = [...session.todos].sort(
                      (a, b) => a.ordering - b.ordering || a.id - b.id
                    );
                    const targetIdx = sorted.findIndex((t) => t.id === targetId);
                    const before = targetIdx > 0 ? sorted[targetIdx - 1] : null;

                    if (before) {
                      todo.ordering = Math.floor((before.ordering + target.ordering) / 2);
                    } else {
                      todo.ordering = target.ordering - 10;
                    }
                  }
                } else if (type === 'after' && targetId !== undefined) {
                  const target = session.todos.find((t) => t.id === targetId);
                  if (target) {
                    const sorted = [...session.todos].sort(
                      (a, b) => a.ordering - b.ordering || a.id - b.id
                    );
                    const targetIdx = sorted.findIndex((t) => t.id === targetId);
                    const after = targetIdx < sorted.length - 1 ? sorted[targetIdx + 1] : null;

                    if (after) {
                      todo.ordering = Math.floor((target.ordering + after.ordering) / 2);
                    } else {
                      todo.ordering = target.ordering + 10;
                    }
                  }
                }
              }
            }
          }
        });
      }

      // Sync to database via tRPC
      // Get fresh copy after optimistic update
      const updatedSession = sessionStore.currentSession;
      if (updatedSession && updatedSession.id === sessionId) {
        const client = getTRPCClient();
        await client.todo.update.mutate({
          sessionId,
          todos: updatedSession.todos,
          nextTodoId: updatedSession.nextTodoId,
        });
      }
    },
  })
);
